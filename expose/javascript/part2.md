Questions and Answers for Part 2
1) 3 is printed since i is a var type, meaning that it is a global variable and that there were only 3 elements in the parameter prices, hence only printing 3, the value of i.
2) 150 is printed since it's the last discounted price that is calculated and stored in the discountedPrice variable while going through the for loop.
3) 150 is printed since it's the last final price that is calculated and stored in the finalPrice variable while going through the for loop.
4) Nothing is printed since all the printing messages within the function are commented out. discounted variable will be returned from this function. 
5) An error is caused as the message displays as an uncaught referenceError: i is not defined. i is only defined within the scope of the for loop as a let type and therefore is not accessible outside of the for loop, causing the error to occur.
6) The same error occurs at line 13 as line 12 with the uncaught referenceError saying that discountedPrice is not defined. discountedPrice is only defined within the scope of the for loop as a let type and therefore is not accessible outside of the for loop, causing the error to occur.
7) 150 is printed since it's the last final price that is calculated and stored in the finalPrice variable while going through the for loop. It does not run into an error since it is declared within the scope of the function and the print call occurs within the function. If it wasn't called within the scope of the function, as a let type, finalPrice will also cause an error.
8) Nothing is printed since all the printing messages within the function are commented out. discounted variable will be returned from this function.
9) An error is caused as the message displays as an uncaught referenceError: i is not defined. i is only defined within the scope of the for loop as a let type and therefore is not accessible outside of the for loop, causing the error to occur.
10) It will return an integer of 3 since the parameter array had a size of 3. 
11) Nothing is printed since all the printing messages within the function are commented out. discounted variable will be returned from this function.
12) A) student.name B) student['Grad Year'] C) student.greeting() D)student['Favorite Teacher'].name E) student.courseLoad[0]
13) A) '32' because '3' came from type of 2 was converted to string and added to the string '3'. B) 1 because '3' was converted into an integer and 3 - 2 = 1. C) 3 because null is effectively converted to 0, 3 + 0 = 3. D) '3null' because null is converted to a string and appended to '3', resulting in '3null'. E) 4 because true maps out to 1, 1 + 3 = 4. F) 0 because false maps to 0 and null also maps to 0, 0 + 0 = 0. G) '3undefined' because undefined is converted/mapped to a string and appended to '3'. H) NaN because '3' is converted numerically to a number and 3 - undefined will convert to NaN because undefined converts to NaN numerically.
14) A) true because in comparison, '2' converts to a number and 2 > 1. B) false because both sides were strings so alphabetical/numerical ordering applies, 2 > 1, so '2' > '12' C) true because regular equality check will convert '2' to integer 2, thus making the comparison 2 == 2 and true. D) false because strict equality check automatically makes different type comparisons return false. E) false because true maps out to integer 1 and 1 does not equal to 2. F) true because boolean(2) maps out to true, thus making true === true statement true.
15) The difference between == and === operators is that == is a regular equality check that will accept different type comparisons and conversions to the same value, thus making statements like 2 == '2' true and also cannot differentiate 0 from false since false maps to 0 numerically and 0 == 0 will become true in a regular equality check. === is a strict equaltiy check that will do everything == will do except that if the two values compared are of different types, it will automatically return false, thus being abel to differentiate between 0 and false. (0 === false will return false).
16) part2-question16.js
17) 
